import string

KEYLETS = string.ascii_uppercase
VARLETS = string.ascii_lowercase + '_'
LETTERS = KEYLETS + VARLETS
DIGITS = {'ZERO':'0','ONE':'1','TWO':'2','THREE':'3','FOUR':'4','FIVE':'5','SIX':'6','SEVEN':'7','EIGHT':'8','NINE':'9','DOT':'.'}
OTHER = {'ADD': '+', 'SUB': '-', 'MUL': '*', 'DIV': '/', 'FLD':'//', 'MOD': '%', 'POW': '**', 'NEG': '-', 'L': '(', 'R': ')'}
MONOS = {'IS':'IS','CLG':'CLG','FLR':'FLR','RND':'RND','DEL':'DEL'}


########################################
# ERROR
########################################

class Error:
    __slots__ = ('location','length','message')

    def __init__(self,location,length,message=None):
        self.location = location
        self.length = length
        self.message = message

    def __str__(self):
        return f"{self.error_arrow()}\n{self.__class__.__name__}: {self.message} in positions {self.location} to {self.location + self.length-1}"

    def error_arrow(self):
        # draws ^ under error location
        return f"{' ' * (self.location-self.length) + ''}{'^'*self.length}"

########################################
# TOKENS
########################################

class Token:
    def __init__(self,type_,value):
        self.value = value
        self.type = type_

    def __repr__(self):
        # 'INT:THREE'
        return f"{self.type}:{self.value}"

class VarToken:
    def __init__(self,name,value):
        self.name = name
        self.value = value
        self.type = 'VAR'

    def __repr__(self):
        # 'x:THREE'
        return f"{self.name}:{self.value}"

class MonoToken:
    def __init__(self,type_):
        self.type = type_

    def __repr__(self):
        # 'IS'
        return f"{self.type}"

class DelToken:
    def __repr__(self):
        # 'DEL'
        return f"DEL"

########################################
# LEXER
########################################

class Lexer:
    def __init__(self,text):
        self.text = text
        self.index = -1
        self.current_char = None
        self.next()

    def next(self):
        # move to next char in input
        self.index += 1
        self.current_char = self.text[self.index] if self.index < len(self.text) else "EOF"

    def make_tokens(self):
        tokens = []

        # self.next()

        while self.current_char:
            # ignore blank space
            if self.current_char in " \t\n":
                self.next()

            # lowercase -> make variable
            elif self.current_char.islower() or self.current_char == '_':
                tokens.append(VarToken(*self.make_variable()))
                self.next()
            # uppercase -> keyword
            else:
                string_ = self.make_string()
                # if string is not digit ex: ADD
                if string_ in OTHER:
                    tokens.append(Token(string_, OTHER[string_]))
                    self.next()
                # if string is digit ex: TWO
                elif string_ in DIGITS:
                    tokens.append(Token('DOT' if string_ == 'DOT' else 'NUM', DIGITS[string_]))
                    self.next()
                elif string_ in MONOS:
                    tokens.append(MonoToken(string_))
                elif string_ == 'DEL':
                    tokens.append(DelToken)
                # EOF
                elif self.current_char == 'EOF':
                    break
                # Return any errors
                else:
                    print(self.text)
                    return Error(self.index, len(string_), "Unknown word")

        if len(tokens) > 0:
            return self.make_numbers(tokens)
        return Error(self.index,1,f"Unknown character:{self.current_char}")

    def make_variable(self):
        var_str = self.current_char
        self.next()

        while self.current_char and self.current_char in VARLETS:
            var_str += self.current_char
            self.next()
        return var_str,None

    def make_string(self):
        key_str = self.current_char
        self.next()

        while self.current_char and self.current_char in KEYLETS:
            key_str += self.current_char
            self.next()
        return key_str

    def make_numbers(self,tokens):
        final_tokens = []
        num_str = ''
        # track decimal and hyphen count
        decimal_count = 1 if tokens[0] == 'DOT' else 0
        hyphen_count = 1 if tokens[0] == 'NEG' else 0

        for token in tokens:
            if token.type in ['NUM','DOT','NEG']:
                # track decimals
                if token.type == 'DOT':
                    if decimal_count > 0:
                        return 'Decimal Error'
                    decimal_count += 1
                # track hyphens
                elif token.type == 'NEG':
                    if len(num_str) > 0:
                        return 'Hyphen must be at beginning of number'
                    elif hyphen_count > 0:
                        # shouldn't affect subtraction since this only tracks NEG tokens
                        return 'Multiple hyphen symbols Error'
                    hyphen_count += 1
                # add to number string
                num_str += token.value
            else:
                # float or integer
                if num_str:
                    final_tokens.append(Token("FLT" if '.' in num_str else "INT",num_str))
                    num_str = ''
                final_tokens.append(token)

        # ensure all digits accounted for
        if num_str:
            final_tokens.append(Token("FLT" if '.' in num_str else "INT",num_str))

        # print(final_tokens)
        return final_tokens


def token_test():
    strings = [
        # valid
        'DEL var NEG TWO ONE DOT FOUR ADD THREE THREE MUL var_one'
    ]
    testing = 0
    for string in strings:
        lexer = Lexer(string)
        print(lexer.make_tokens())
        testing += 1

# token_test()
