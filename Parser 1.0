from Lexer import Lexer, Token, VarToken, MonoToken, DelToken, Error
import math

VARIABLES = {}

class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.index = -1
        self.current_token = None
        self.next()

    def next(self):
        self.index += 1
        self.current_token = self.tokens[self.index] if self.index < len(self.tokens) else None

    def parse(self):
        # Check if input starts with variable
        if self.current_token and self.current_token.type == 'VAR':
            # If next token is IS -> assign variable to rest of input (x IS TWO -> VARIABLES['x'] = 2)
            if len(self.tokens) > 1:

                if self.index + 1 < len(self.tokens):
                    if self.tokens[self.index+1].type == 'IS':
                        variable_name = self.current_token.name
                        self.next()  # Move past the variable name
                        self.next()  # Move past 'IS'
                        value = self.parse_expression()
                        VARIABLES[variable_name] = value
                        return f'Assigned: {variable_name} = {value}'
                    else:
                        return self.parse_expression()
            # only var in line -> print variable value
            else:
                if self.current_token.name in VARIABLES:
                    return VARIABLES[self.current_token.name]
                else:
                    return f'Error: variable "{self.current_token.name}" not found'

        return self.parse_expression()

    def parse_expression(self):
        # addition and subtraction
        result = self.parse_term()

        while self.current_token and self.current_token.type in ['ADD','SUB']:
            if self.current_token.type == 'ADD':
                self.next()
                result += self.parse_term()
            elif self.current_token.type == 'SUB':
                self.next()
                result -= self.parse_term()
        return result

    def parse_term(self):
        # multiplication and division
        result = self.parse_exponent()

        while self.current_token and self.current_token.type in ['MUL','DIV','FLD','MOD']:
            if self.current_token.type == 'MUL':
                self.next()
                result *= self.parse_exponent()
            elif self.current_token.type == 'DIV':
                self.next()
                divisor = self.parse_exponent()
                if divisor == 0:
                    return 'Error: Division by zero'
                else:
                    result /= divisor
            elif self.current_token.type == 'FLD':
                self.next()
                divisor = self.parse_exponent()
                if divisor == 0:
                    return 'Error: Division by zero'
                else:
                    result //= divisor
            elif self.current_token.type == 'MOD':
                self.next()
                divisor = self.parse_exponent()
                if divisor == 0:
                    return 'Error: Division by zero'
                else:
                    result %= divisor
        return result

    def parse_exponent(self):
        # exponent
        result = self.parse_factor()

        while self.current_token and self.current_token.type == 'POW':
            self.next()
            result **= self.parse_factor()

        return result

    def parse_factor(self):
        # variables, numbers, negative, parentheses, monos
        token = self.current_token
        if isinstance(token,VarToken) and token.type == 'VAR':
            _ = self.get_variable_value()
            if _:
                try:
                    self.next()
                    return float(_) if '.' in str(_) else int(_)
                except:
                    return f'Variable "{self.current_token.name}" must be a number'
            else:
                return f'Variable "{self.current_token.name}"'

        elif isinstance(token,Token) and token.type in ['INT','FLT']:
            self.next()
            return float(token.value) if '.' in token.value else int(token.value)

        elif isinstance(token,Token) and token.type == 'NEG':
            self.next()
            return -self.parse_factor()
        # parentheses
        elif isinstance(token,Token) and token.type == 'L':
            self.next()
            result = self.parse_expression()
            if self.current_token and self.current_token.type != 'R':
                return 'Error: Mismatched parentheses'
            self.next()
            return result
        # mono tokens
        elif isinstance(self.current_token, MonoToken):
            if self.current_token.type == 'CLG':
                self.next()
                result = math.ceil(self.parse_expression())
                return result
            elif self.current_token.type == 'FLR':
                self.next()
                result = math.floor(self.parse_expression())
                return result
            elif self.current_token.type == 'RND':
                self.next()
                result = round(self.parse_expression())
            return result
        else:
            return f"Error: Unexpected token: {token}"

    def show_equation(self, result, with_answer=True):
        eq_str = ''
        for token in self.tokens:
            eq_str += token.value
        return f'{eq_str} = {result}' if with_answer else eq_str

    def get_variable_value(self):
        if self.current_token.name in VARIABLES:
            return VARIABLES[self.current_token.name]
        else:
            return f'Variable "{self.current_token.name}" unassigned'

def main():
    run = True
    while run:
        line = input('> ')

        if line.upper() == 'EXIT':
            run = False
        elif line == '':
            continue
        # see all variables
        elif line.strip() == 'VARDICT':
            print(VARIABLES)

        else:
            lexer = Lexer(line)
            tokens = lexer.make_tokens()
            parser = Parser(tokens)
            result = parser.parse()
            print(parser.show_equation(result) if line.endswith('SHEQ') else result)


if __name__ == '__main__':
    main()

# 2.75 * (3 - 5) ^ 4 / 3 -> 14.67
# TWO DOT SEVEN FIVE MUL L THREE SUB FIVE R POW FOUR DIV THREE
